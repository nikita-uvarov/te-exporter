// Часть строки начинающаяся с первого вхождения "//" является комментарием. Пробелы в конце строк игнорируются (последним символом строки считается последний непробельный символ).
/* Комментарии в стиле C++
   также поддерживаются с целью оставить возможность быстро убирать целые секции */

// Параметры экспорта данных определяются отдельно от данных. Поэтому файл содержит сколь угодно много вопросов сколь угодно длинного интервала времени. Деление на несколько файлов происходит лишь по большим кускам.
// Таким образом, 1. файл напоминает тетрадный конспект и 2. его удобно хранить в git.

// Система должна быть ориентирована на ввод русского текста - спец. символы выбираются с учётом возможности набора без смены раскладки. (например, избегаются: " '{}[]<> ")

// Основной тип данных - текст, в котором поддерживаются некоторые конструкции.
// ` используется для постановки спецсимвола ударения (вставляется перед буквой, над которой его следует поставить).
// \ не в конце строки используется для экранирования символов - далее символы, следующие за \, называются экранированными.

// Конечными символами называются точка, знак вопроса и закрывающаяся скобка.

// Базовые даты указываются в одном из трёх форматов: dd.mm.yyyy или mm.yyyy или yyyy.
// Вместо mm можно использовать название месяца на русском (в именительном или родительном падеже) или английском языке (поддерживаются сокращения до трёх букв).
// Составной датой (далее просто датой) называется либо базовая дата, либо интервал в формате "начальная дата-конечная дата" (без пробела между тире и датами).

// Формат данных должен содержать как можно меньше синтаксического мусора.
// При разборе файл разбивается на блоки из непустых строк.

// Если начало первой в блоке строки можно интерпретировать как дату, блок воспринимается как описание исторической даты.
// Следующим символом обязано быть тире, отделённое от даты не менее чем одним пробелом, затем - название исторического события.
// Последующие строки содержат (опциаональное) подробное описание события.
// Благодаря такому формату возможно тестирование в трёх режимах: по дате - название, по названию - дату, по названию - описание.
// Предупреждение выдаётся, если строки подробного описания или названия события содержат неэкранированные тире.
// Предупреждение выдаётся, если последний символ названия является неэкранированным и конечным.

дата - событие
подробное описание,
продолженние подробного описания.

// Если начало описания блока содержит ровно одно неэкранированное тире, он считается определением термина.
// После определения следует опциональный "инвертированный вопрос", ответом на который является этот термин.
// Таким образом, тестирование может проводится в двух режимах (термин - определение, определение - термин).
// Предупреждение выдаётся, если последний символ определения является не экранированным и не конечным.

термин - определение.
инвертированный вопрос,
продолжение инвертированного вопроса?

// Если блок начинается с тире, он обязан состоять ровно из одной строки с тремя последоватльными тире.
// Все события в базе имеют собственную дату. Термины и вопросы, по умолчанию, относятся к предыдущему событию.
// Разделитель позволяет принудительно отнести последующие термины и вопросы к первому событию после разделителя

---

// Если блок начинается с открывающейся квадратной скобкой, он обязан быть однострочным и заканчиваться парной скобкой.
// Блок определяет тег темы для всех последующих записей.
// Предупреждение выдаётся, если тег темы состоит не только из строчных символов латинского алфавита и знака минуса.
[alexander-i-domestic-policy]

// Во всех остальных случаях, блок интерпретируется как вопрос.
// В случае, если в вопросе содержится неэкранированное тире, или если он заканчивается на не конеччный символ, или если ответ отсутствует, выдаётся предупреждение.

вопрос?
Ответ
Возможно на нескольких строчках

// Сценарии экспорта

var="value"

rdb first "first-quiz.txt"
rdb second "second-quiz.txt"
mergedb quiz first second
filtertag filtered mergedb alexander-i-domestic-policy

export filtered -export-terms="definition-to-name"

// Фактически, задача на одно утро на парсинг.
// Вызов: te-exporter scenery.txt

// Update-1:
// Переопределение преамбулы, включения и картинки в карточках

// Для управления процессом преобразования записей в карточки используются строки, начинающиеся с '#':

// Для задания глобальных и локальных настроек используется т. н. стек переменных
// Переменная помещается в стек директивой #push identifier: value
#push variable: the rest of the line is value\nwith escape sequences probably
// Значение переменной берётся из ближайшей к вершине записи о ней
#push variable: value has been overriden
// Для пустого значения можно использовать конструкцию (без пробелов после имени):
#push variable
// Переменную можно удалить или вернуть к старому значению
#pop variable
// Для удаления последней переменной аргумент может быть опущен
#pop

// Строки директив обрабатываются до выделения блоков и превращаются в пустые строки.
// ПРАВКА: на самом деле они также являются разделителями блоков, как и, например, теги.

// Некоторые переменные влияют на преобразование записей в карточки.
// Например, содержащие т. н. преамбулу - описание требуемого от пользователя ответа, помещаемое в скобки после текста задания.
#push simple_date_to_name_preamble: название события

// В тексте значения можно использовать $имя-переменной для подстановки её значения. За конструкцией обязан следовать пробел (или перевод строки), который опускается.
// Отсутствие переменной в стеке является ошибкой.
#push localization_month_01_input_variants: january jan
#push localization_month_01_input_variants: январь января $localization_month_01_input_variants

// Для включения в карточки картинок используется переменная image: в карточку будет вставлена картинка, если в момент её чтения переменная определена.
#push image: relative-path/watermelon.txt
Что нарисовано на картинке?
Арбуз
#pop

// Наконец, так как переменные используются для локализации, возможно включение файлов друг в друга:
#include path-to-file.txt
// Имя файла ищется сначала относительно директории файла, в котором прочитана директива, затем относительно директорий всех файлов, обрабатываемых в данный момент, затем
// относительно путей binary-dir/headers и binary-dir/../headers, если они существуют.
// Если ни в одной из директорий файл не найден, выдаётся ошибка.
// Перед началом чтения базы данных включается файл global.txt (согласно правилам поиска включаемых файлов).
// Глубина включения файлов не может превышать некоторой константы (100).

// Некоторые базы данных не являются историческими; в этом случае определение переменной disable-historical-events запретит определения явлений и будет выдывать предупреждения для всех похожих на них блоков.
#push disable-historical-events

// Update-2:
// Стоит постепенно отвязать систему от:
// - исторической направленности - пусть останется хорошая концепция блоков и удобочитаемый формат.
// - ориентированности на Flashcards Deluxe - пусть будет некоторый промежуточный формат, экпортируемый в FD только на последней стадии.



// kate: syntax ActionScript 2.0;